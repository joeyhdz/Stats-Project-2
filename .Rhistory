plot(glm.roc, print.thres = "best", print.thres.best.method = "closest.topleft", col = "red")
legend("bottomright",# add legend to plot
legend = 'caret model',
col = "red",
lwd = 4, cex = 1, xpd = T, horiz = F)
# fitting model for AIC below
red.glm <- glm(fracture~site_id+priorfrac+momfrac+raterisk+fracscore+bonemed_fu+bmi.cat,
data = training,family = "binomial")
red.glm.aic<-AIC(red.glm)
red.glm.aic
# get coord (threshold)
coords <- coords(glm.roc, "best", best.method = "closest.topleft", ret = "threshold")
# get optimal threshold
threshold <- coords[[1]] # currently this is 0.25653
# make changes to threshold if desired
adj.threshold <- threshold + 0
# adjust the labeling by the desired threshold
pred_label <- as.factor(ifelse(glm.predprob$Yes >= adj.threshold, "Yes","No"))
# print confusion matrix
(cm1 <- confusionMatrix(pred_label, test$fracture, positive = "Yes"))
cat("GLMNET Model",
"\nSensitivity:", cm1$byClass[1],
"\nSpecificity:", cm1$byClass[2],
"\nPrevalence:", cm1$byClass[8],
"\nPositive Predicitve Value:", cm1$byClass[3],
"\nNegative Predicive Value:",cm1$byClass[4],
"\nAUROC:", glm.roc$auc)
# parameters for train function
fitControl <- trainControl( method = "repeatedcv", number = 5, repeats = 1, classProbs = T, summaryFunction = mnLogLoss)
# set seed for reproduceability
set.seed(12)
# training CARET mult. logi. regression model
complex.cv <- train(fracture~age+priorfrac+height+momfrac+bonemed+bmi+bonemed_fu+height:bonemed_fu+bonemed:bmi,
data = training,
trControl = fitControl,
method = "glm",
family = "binomial",
metric = "logLoss")
summary(complex.cv)
# make preds on the probabilty of each class in TRANING data
complexcv.predprob <- predict(complex.cv, test, type = "prob")
# compute the ROC curve
complexcv.roc <- roc(response = test$fracture, predictor = complexcv.predprob$Yes, levels = c("Yes","No"))
# plot ROC curve
plot(complexcv.roc, print.thres = "best", print.thres.best.method = "closest.topleft", col = "red")
# add legend to plot
legend("bottomright",
legend = 'caret model',
col = "red",
lwd = 4, cex = 1, xpd = T, horiz = F)
# printing out all AIC metrics (note they are based on training data not test data)
cat("\nbase.adj Model (Additive):", base.aic,
"\nRed Model (Additive):", red.aic,
"\nComplex Model:", complex.aic)
# get coord (threshold)
coords <- coords(complexcv.roc, "best", best.method = "closest.topleft", ret = "threshold")
# get optimal threshold
threshold <- coords[[1]] # currently this is 0.25653
# make changes to threshold if desired
adj.threshold <- threshold + 0
# adjust the labeling by the desired threshold
pred_label <- as.factor(ifelse(complexcv.predprob$Yes >= adj.threshold, "Yes","No"))
# print confusion matrix
(cm3 <-confusionMatrix(pred_label, test$fracture, positive = "Yes"))
cat("\nSensitivity:", cm3$byClass[1],
"\nSpecificity:", cm3$byClass[2],
"\nPrevalence:", cm3$byClass[8],
"\nPositive Predicitve Value:", cm3$byClass[3],
"\nNegative Predicive Value:",cm3$byClass[4],
"\nAUROC:", complexcv.roc$auc)
colnames(training)
glm.df <- training[,-c(1:3,8,20)]
set.seed(12)
fitControl<- trainControl(method = "repeatedcv", number = 5, repeats = 1)
glm.fit <- train(fracture~.,
data = glm.df,
method = "glmnet",
trControl = fitControl)
glm.fit
plot(glm.fit)
opt.pen<- glm.fit$finalModel$lambdaOpt
coef(glm.fit$finalModel, opt.pen)
# parameters for train function
fitControl <- trainControl( method = "repeatedcv", number = 5, repeats = 1, classProbs = T, summaryFunction = mnLogLoss)
# set seed for reproduceability
set.seed(12)
# training CARET mult. logi. regression model
red.glm <- train(fracture~priorfrac+momfrac+raterisk+fracscore+bonemed_fu+bmi.cat,
data = training,
trControl = fitControl,
method = "glm",
family = "binomial",
metric = "logLoss")
summary(red.glm)
# make preds on the probabilty of each class in TRANING data
glm.predprob <- predict(red.glm, test, type = "prob")
# compute the ROC curve
glm.roc <- roc(response = test$fracture, predictor = glm.predprob$Yes, levels = c("Yes","No"))
# plot ROC curve
plot(glm.roc, print.thres = "best", print.thres.best.method = "closest.topleft", col = "red")
# add legend to plot
legend("bottomright",
legend = 'caret model',
col = "red",
lwd = 4, cex = 1, xpd = T, horiz = F)
# fitting model for AIC below
red.glm <- glm(fracture~priorfrac+momfrac+raterisk+fracscore+bonemed_fu+bmi.cat,
data = training,family = "binomial")
red.glm.aic<-AIC(red.glm)
# printing out all AIC metrics (note they are based on training data not test data)
cat("\nbase.adj Model (Additive):", base.aic,
"\nRed Model (Additive):", red.aic,
"\nComplex Model:", complex.aic,
"\nRed.GLM Model(additive):", red.glm.aic)
# get coord (threshold)
coords <- coords(glm.roc, "best", best.method = "closest.topleft", ret = "threshold")
# get optimal threshold
threshold <- coords[[1]] # currently this is 0.25653
# make changes to threshold if desired
adj.threshold <- threshold + 0
# adjust the labeling by the desired threshold
pred_label <- as.factor(ifelse(glm.predprob$Yes >= adj.threshold, "Yes","No"))
# print confusion matrix
(cm4 <- confusionMatrix(pred_label, test$fracture, positive = "Yes"))
cat("\nSensitivity:", cm4$byClass[1],
"\nSpecificity:", cm4$byClass[2],
"\nPrevalence:", cm4$byClass[8],
"\nPositive Predicitve Value:", cm4$byClass[3],
"\nNegative Predicive Value:",cm4$byClass[4],
"\nAUROC:", glm.roc$auc)
# parameters for train function
fitControl <- trainControl( method = "repeatedcv", number = 5, repeats = 1, classProbs = T, summaryFunction = mnLogLoss)
# set seed for reproduceability
set.seed(12)
# training CARET mult. logi. regression model
complex.glm <- train(fracture ~ site_id + priorfrac + momfrac + raterisk + fracscore + bonemed_fu + bmi.cat +
bonemed_fu:bmi.cat,
data = training,
trControl = fitControl,
method = "glm",
family = "binomial",
metric = "logLoss")
summary(complex.glm)
# make preds on the probabilty of each class in TRANING data
complex.glm.predprob <- predict(complex.glm, test, type = "prob")
# compute the ROC curve
complex.glm.roc <- roc(response = test$fracture, predictor = complex.glm.predprob$Yes, levels = c("Yes","No"))
# plot ROC curve
plot(complex.glm.roc, print.thres = "best", print.thres.best.method = "closest.topleft", col = "red")
# add legend to plot
legend("bottomright",
legend = 'GLM Complex',
col = "red",
lwd = 4, cex = 1, xpd = T, horiz = F)
complex.glm <- glm(fracture ~ priorfrac + momfrac + raterisk + fracscore + bonemed_fu + bmi.cat +
bonemed_fu:bmi.cat,
data = training,family = "binomial")
# AIC
complex.glm.aic<-AIC(complex.glm)
# printing out all AIC metrics (note they are based on training data not test data)
cat("\nbase.adj Model (Additive):", base.aic,
"\nRed Model (Additive):", red.aic,
"\nComplex Model:", complex.aic,
"\nRed.GLM Model(additive):", red.glm.aic,
"\nComplex.GLM:",complex.glm.aic)
# get coord (threshold)
coords <- coords(complexcv.roc, "best", best.method = "closest.topleft", ret = "threshold")
# get optimal threshold
threshold <- coords[[1]] # currently this is 0.25653
# make changes to threshold if desired
adj.threshold <- threshold + 0
# adjust the labeling by the desired threshold
pred_label <- as.factor(ifelse(complexcv.predprob$Yes >= adj.threshold, "Yes","No"))
# print confusion matrix
(cm5 <- confusionMatrix(pred_label, test$fracture, positive = "Yes"))
cat("\nSensitivity:", cm5$byClass[1],
"\nSpecificity:", cm5$byClass[2],
"\nPrevalence:", cm5$byClass[8],
"\nPositive Predicitve Value:", cm5$byClass[3],
"\nNegative Predicive Value:",cm5$byClass[4],
"\nAUROC:", complex.glm.roc$auc)
knn.df <- training[,-c(1)]
fitControl <- trainControl(method = "repeatedcv",number = 5, repeats = 1, classProbs = T, summaryFunction = mnLogLoss)
set.seed(12)
knn.model <- train(fracture~ .,
method = "knn",
data = knn.df,
trControl = fitControl,
metric = "logLoss")
preds <- predict(knn.model, test, type ="prob")[,"Yes"]
knn.roc <- roc(response = test$fracture, predictor = preds, levels = c("Yes","No"))
plot(knn.roc,print.thres = "best", print.thres.best.method = "closest.topleft", col = "purple")
plot(complexcv.roc, print.thres = "best", print.thres.best.method = "closest.topleft", col = "lightblue")
plot(glm.roc, print.thres = "best", print.thres.best.method = "closest.topleft", col = "black", add = T)
plot(complex.glm.roc, print.thres = "best", print.thres.best.method = "closest.topleft", col = "red", add = T)
plot(knn.roc,print.thres = "best", print.thres.best.method = "closest.topleft", col = "purple", add = T)
# add legend to plot
legend("bottomright",
legend = c("Complex","GLM Additive",'GLM Complex', "KNN"),
col = c("lightblue","black","red","purple"),
lwd = 4, cex = 1, xpd = T, horiz = F)
# coords(complexcv.roc, "best", ret = c("threshold", "specificity", "sens"), transpose = F)
# coords(glm.roc, "best", ret = c("threshold","specificity","sens"), transpose = F)
# coords(complex.glm.roc, "best", ret = c("threshold","specificity","sens"), transpose=F)
threshold = .5
knn.preds <- factor(ifelse(preds > threshold, "Yes","No"))
(cm6 <- confusionMatrix(data = knn.preds, reference = as.factor(test$fracture), positive = "Yes"))
cat("\nSensitivity:", cm6$byClass[1],
"\nSpecificity:", cm6$byClass[2],
"\nPrevalence:", cm6$byClass[8],
"\nPositive Predicitve Value:", cm6$byClass[3],
"\nNegative Predicive Value:",cm6$byClass[4],
"\nAUROC:", knn.roc$auc)
set.seed(12)
fitControl<- trainControl(method = "repeatedcv", number = 5, repeats = 1)
lambda_values <- seq(0,.03,by = .001)
lasso.fit <- train(fracture ~ .,
data = glm.df,
method = "glmnet",
trControl = fitControl,
tuneGrid = expand.grid(data.frame(alpha = 1, lambda = lambda_values)))
lasso.fit
plot(lasso.fit)
opt.pen<- lasso.fit$finalModel$lambdaOpt
coef(lasso.fit$finalModel, opt.pen)
set.seed(12)
fitControl<- trainControl(method = "repeatedcv", number = 5, repeats = 1)
lambda_values <- seq(0,.03,by = .001)
lasso.fit <- train(fracture ~ .,
data = adj.training,
method = "glmnet",
trControl = fitControl,
tuneGrid = expand.grid(data.frame(alpha = 1, lambda = lambda_values)))
lasso.fit
plot(lasso.fit)
opt.pen<- lasso.fit$finalModel$lambdaOpt
coef(lasso.fit$finalModel, opt.pen)
set.seed(12)
fitControl<- trainControl(method = "repeatedcv", number = 5, repeats = 1)
lambda_values <- seq(0,.03,by = .001)
lasso.fit <- train(fracture ~ .,
data = adj.training,
method = "glmnet",
trControl = fitControl,
tuneGrid = expand.grid(data.frame(alpha = 1, lambda = lambda_values)))
lasso.fit
plot(lasso.fit)
opt.pen<- lasso.fit$finalModel$lambdaOpt
coef(lasso.fit$finalModel, opt.pen)
lasso.model <- glm(fracture ~ priorfrac+ raterisk + bonemed_fu + momfrac + fracscore + bmi.cat,
data = training,
family = "binomial")
summary(lasso.model)
# checking for multicollinearity issues.
vif(lasso.model) #no issues present
# parameters for train function
fitControl <- trainControl( method = "repeatedcv", number = 5, repeats = 1, classProbs = T, summaryFunction = mnLogLoss)
# set seed for reproduceability
set.seed(12)
# training CARET mult. logi. regression model
lasso.model.cv <- train(fracture ~ priorfrac+ raterisk + bonemed_fu + momfrac + fracscore + bmi.cat,
data = training,
trControl = fitControl,
method = "glm",
family = "binomial",
metric = "logLoss")
#summary(base.adjust.cv)
base.aic <- AIC(lasso.model) # 381.87
# make preds on the probabilty of each class in TRANING data
add.model.predprob <- predict(lasso.model.cv,test, type = "prob")
# compute the ROC curve
add.model.roc <- roc(response = test$fracture, predictor = add.model.predprob$Yes, levels = c("Yes","No"))
# optimal threshold
optimal.threshold <- coords(add.model.roc, "best")
# plot ROC curve
plot(add.model.roc, print.thres = "best",
#print.thres.best.method = "closest.topleft",
col = "red")
# add legend to plot
legend("bottomright",
legend = 'Additive model',
col = "red",
lwd = 4, cex = 1, xpd = T, horiz = F)
text(x = optimal.threshold[1], y = optimal.threshold[2],
labels = paste("Optimal Threshold =", round(optimal.threshold[1], 2)),
pos = 3)
# get coord (threshold)
coords <- coords(add.model.roc, "best",
#best.method = "closest.topleft",
ret = "threshold")
# get optimal threshold
threshold <- coords[[1]] # currently this is 0.3003923
# make changes to threshold if desired
adj.threshold <- threshold + .4 # lower increases sensitivity
# adjust the labeling by the desired threshold
pred_label <- as.factor(ifelse(add.model.predprob$Yes > adj.threshold, "Yes","No"))
# print confusion matrix
(cm1 <- confusionMatrix(pred_label, test$fracture, positive = "Yes"))
cat("\nSensitivity:", cm1$byClass[1],
"\nSpecificity:", cm1$byClass[2],
"\nPrevalence:", cm1$byClass[8],
"\nPositive Predicitve Value:", cm1$byClass[3],
"\nNegative Predicive Value:",cm1$byClass[4],
"\nAUROC:", add.model.roc$auc)
ggpairs(num.df)
colnames(num.df)
num.df %>% ggplot(aes(x =age,y = weight, color = as.factor(fracture.num))) +
geom_point()+geom_density_2d()
num.df %>% ggplot(aes(x = age, y = height, color = as.factor(fracture.num)))+
geom_point() + geom_density_2d()
num.df %>% ggplot(aes(x = age, y = bmi, color = as.factor(fracture.num)))+
geom_point() + geom_density_2d()
num.df %>% ggplot(aes(x = age, y = fracscore, color = as.factor(fracture.num)))+
geom_point() + geom_density_2d()
num.df %>% ggplot(aes(x = weight, y = height, color = as.factor(fracture.num)))+
geom_point() + geom_density_2d()
num.df %>% ggplot(aes(x = bmi, y = height, color = as.factor(fracture.num)))+
geom_point() + geom_density_2d()
num.df %>% ggplot(aes(x = fracscore, y = height, color = as.factor(fracture.num)))+
geom_point() + geom_density_2d()
num.df %>% ggplot(aes(x = bmi, y = weight, color = as.factor(fracture.num)))+
geom_point() + geom_density_2d()
num.df %>% ggplot(aes(x = bmi, y = fracscore, color = as.factor(fracture.num)))+
geom_point() + geom_density_2d()
fitControl <- trainControl(method="repeatedcv",
number=5,
repeats=1,
classProbs=TRUE,
summaryFunction=mnLogLoss)
set.seed(12)
qda.fit <- train(fracture~age+weight+height+bmi+fracscore,
data = training,
method = "qda",
trControl = fitControl,
metric = "logLoss")
predictions <- predict(qda.fit, test, type = "prob")[,"Yes"]
threshold = .258
class_pred = as.factor(ifelse(predictions > threshold, "Yes","No"))
(cm7<-confusionMatrix(data = class_pred, reference = test$fracture, positive = "Yes"))
qda.roc <- roc(response = test$fracture, predictor = predictions, levels = c("Yes","No"))
plot(qda.roc, print.thres = "best", col = "lightblue")
cat("\nSensitivity:", cm7$byClass[1],
"\nSpecificity:", cm7$byClass[2],
"\nPrevalence:", cm7$byClass[8],
"\nPositive Predicitve Value:", cm7$byClass[3],
"\nNegative Predicive Value:",cm7$byClass[4],
"\nAUROC:", qda.roc$auc)
lasso.model <- glm(fracture ~ priorfrac+ raterisk + bonemed_fu + fracscore + bmi.cat,
data = training,
family = "binomial")
summary(lasso.model)
# checking for multicollinearity issues.
vif(lasso.model) #no issues present
# parameters for train function
fitControl <- trainControl( method = "repeatedcv", number = 5, repeats = 1, classProbs = T, summaryFunction = mnLogLoss)
# set seed for reproduceability
set.seed(12)
# training CARET mult. logi. regression model
lasso.model.cv <- train(fracture ~ priorfrac+ raterisk + bonemed_fu + momfrac + fracscore + bmi.cat,
data = training,
trControl = fitControl,
method = "glm",
family = "binomial",
metric = "logLoss")
#summary(base.adjust.cv)
base.aic <- AIC(lasso.model) # 381.87
# make preds on the probabilty of each class in TRANING data
add.model.predprob <- predict(lasso.model.cv,test, type = "prob")
# compute the ROC curve
add.model.roc <- roc(response = test$fracture, predictor = add.model.predprob$Yes, levels = c("Yes","No"))
# optimal threshold
optimal.threshold <- coords(add.model.roc, "best")
# plot ROC curve
plot(add.model.roc, print.thres = "best",
#print.thres.best.method = "closest.topleft",
col = "red")
# add legend to plot
legend("bottomright",
legend = 'Additive model',
col = "red",
lwd = 4, cex = 1, xpd = T, horiz = F)
text(x = optimal.threshold[1], y = optimal.threshold[2],
labels = paste("Optimal Threshold =", round(optimal.threshold[1], 2)),
pos = 3)
# get coord (threshold)
coords <- coords(add.model.roc, "best",
#best.method = "closest.topleft",
ret = "threshold")
# get optimal threshold
threshold <- coords[[1]] # currently this is 0.3003923
# make changes to threshold if desired
adj.threshold <- threshold + .4 # lower increases sensitivity
# adjust the labeling by the desired threshold
pred_label <- as.factor(ifelse(add.model.predprob$Yes > adj.threshold, "Yes","No"))
# print confusion matrix
(cm1 <- confusionMatrix(pred_label, test$fracture, positive = "Yes"))
cat("\nSensitivity:", cm1$byClass[1],
"\nSpecificity:", cm1$byClass[2],
"\nPrevalence:", cm1$byClass[8],
"\nPositive Predicitve Value:", cm1$byClass[3],
"\nNegative Predicive Value:",cm1$byClass[4],
"\nAUROC:", add.model.roc$auc)
lasso.model <- glm(fracture ~ priorfrac+ raterisk + bonemed_fu + momfrac + fracscore + bmi.cat,
data = training,
family = "binomial")
summary(lasso.model)
# checking for multicollinearity issues.
vif(lasso.model) #no issues present
# parameters for train function
fitControl <- trainControl( method = "repeatedcv", number = 5, repeats = 1, classProbs = T, summaryFunction = mnLogLoss)
# set seed for reproduceability
set.seed(12)
# training CARET mult. logi. regression model
lasso.model.cv <- train(fracture ~ priorfrac+ raterisk + bonemed_fu + momfrac + fracscore + bmi.cat,
data = training,
trControl = fitControl,
method = "glm",
family = "binomial",
metric = "logLoss")
#summary(base.adjust.cv)
base.aic <- AIC(lasso.model) # 381.87
# make preds on the probabilty of each class in TRANING data
add.model.predprob <- predict(lasso.model.cv,test, type = "prob")
# compute the ROC curve
add.model.roc <- roc(response = test$fracture, predictor = add.model.predprob$Yes, levels = c("Yes","No"))
# optimal threshold
optimal.threshold <- coords(add.model.roc, "best")
# plot ROC curve
plot(add.model.roc, print.thres = "best",
#print.thres.best.method = "closest.topleft",
col = "red")
# add legend to plot
legend("bottomright",
legend = 'Additive model',
col = "red",
lwd = 4, cex = 1, xpd = T, horiz = F)
text(x = optimal.threshold[1], y = optimal.threshold[2],
labels = paste("Optimal Threshold =", round(optimal.threshold[1], 2)),
pos = 3)
# get coord (threshold)
coords <- coords(add.model.roc, "best",
#best.method = "closest.topleft",
ret = "threshold")
# get optimal threshold
threshold <- coords[[1]] # currently this is 0.3003923
# make changes to threshold if desired
adj.threshold <- threshold + .4 # lower increases sensitivity
# adjust the labeling by the desired threshold
pred_label <- as.factor(ifelse(add.model.predprob$Yes > adj.threshold, "Yes","No"))
# print confusion matrix
(cm1 <- confusionMatrix(pred_label, test$fracture, positive = "Yes"))
cat("\nSensitivity:", cm1$byClass[1],
"\nSpecificity:", cm1$byClass[2],
"\nPrevalence:", cm1$byClass[8],
"\nPositive Predicitve Value:", cm1$byClass[3],
"\nNegative Predicive Value:",cm1$byClass[4],
"\nAUROC:", add.model.roc$auc)
lasso.model <- glm(fracture ~ priorfrac+ raterisk + bonemed_fu + fracscore + bmi.cat,
data = training,
family = "binomial")
summary(lasso.model)
# checking for multicollinearity issues.
vif(lasso.model) #no issues present
# parameters for train function
fitControl <- trainControl( method = "repeatedcv", number = 5, repeats = 1, classProbs = T, summaryFunction = mnLogLoss)
# set seed for reproduceability
set.seed(12)
# training CARET mult. logi. regression model
lasso.model.cv <- train(fracture ~ priorfrac+ raterisk + bonemed_fu + momfrac + fracscore + bmi.cat,
data = training,
trControl = fitControl,
method = "glm",
family = "binomial",
metric = "logLoss")
#summary(base.adjust.cv)
base.aic <- AIC(lasso.model) # 381.87
# make preds on the probabilty of each class in TRANING data
add.model.predprob <- predict(lasso.model.cv,test, type = "prob")
# compute the ROC curve
add.model.roc <- roc(response = test$fracture, predictor = add.model.predprob$Yes, levels = c("Yes","No"))
# optimal threshold
optimal.threshold <- coords(add.model.roc, "best")
# plot ROC curve
plot(add.model.roc, print.thres = "best",
#print.thres.best.method = "closest.topleft",
col = "red")
# add legend to plot
legend("bottomright",
legend = 'Additive model',
col = "red",
lwd = 4, cex = 1, xpd = T, horiz = F)
text(x = optimal.threshold[1], y = optimal.threshold[2],
labels = paste("Optimal Threshold =", round(optimal.threshold[1], 2)),
pos = 3)
# get coord (threshold)
coords <- coords(add.model.roc, "best",
#best.method = "closest.topleft",
ret = "threshold")
# get optimal threshold
threshold <- coords[[1]] # currently this is 0.3003923
# make changes to threshold if desired
adj.threshold <- threshold + .4 # lower increases sensitivity
# adjust the labeling by the desired threshold
pred_label <- as.factor(ifelse(add.model.predprob$Yes > adj.threshold, "Yes","No"))
# print confusion matrix
(cm1 <- confusionMatrix(pred_label, test$fracture, positive = "Yes"))
cat("\nSensitivity:", cm1$byClass[1],
"\nSpecificity:", cm1$byClass[2],
"\nPrevalence:", cm1$byClass[8],
"\nPositive Predicitve Value:", cm1$byClass[3],
"\nNegative Predicive Value:",cm1$byClass[4],
"\nAUROC:", add.model.roc$auc)
